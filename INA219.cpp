/*
 * INA219.cpp
 *
 *  Created on: Jun 2, 2021
 *      Author: Kai Staud
 */

#include "INA219.h"
//#include "main.h"

namespace ADC {
namespace ShuntAmplifier{

INA219::INA219() {
	// TODO Auto-generated constructor stub

}

INA219::~INA219() {
	// TODO Auto-generated destructor stub
}

/*
 *  @brief: Constructor for I2C Initialisation
 *  @ param: I2C Device Address, I2C Handle ( generated by CubeMX)
 *  @ return: none
 */
INA219::INA219(uint8_t addr,I2C_HandleTypeDef i2c_port)
{
	address = addr;
	hi2c = i2c_port;
	configRegister = 0x0000;
}

/* Abstraction Functions for I2C Frame based on I2C Interface */

/*
 * @brief: Writes two bytes to ADC Register
 * @param: register address, word to write to register
 * @return: Transmission Error
 */
HAL_StatusTypeDef INA219::WriteRegister(uint8_t reg, uint16_t data)
{
	HAL_StatusTypeDef tx_error;
	uint8_t txData[3]= {reg,data>>8, data & 0x0F};
	tx_error = HAL_I2C_Master_Transmit(&hi2c, address, txData, 3, 10);
	return tx_error;
}

/*
 * @brief: Reads back ADC Register
 * @param: register address, pointer to array
 * @return: Transmission Error
 */
HAL_StatusTypeDef INA219::ReadRegister(uint8_t reg, uint8_t *pData)
{
	HAL_StatusTypeDef tx_error;
	tx_error = HAL_I2C_Master_Transmit(&hi2c, address, &reg, 1, 10);
	tx_error = HAL_I2C_Master_Receive(&hi2c, address, pData, 2, 10);
	return tx_error;
}

/*   User Functions */

/* Functions for Setting Configuration Register [0x00] */

/*
 * @brief: Sets Bus  and Shunt Voltage, ADC Resolution and Averaging
 * @param: Fullscale Range ofBus and  Shunt Voltage, Resolution for Shunt and Bus ADC
 * @return: none
 */
void INA219::Configure(BusVoltage vb,ShuntVoltage vs,AdcResolution vs_res,AdcResolution vb_res)
{
configRegister &= (0x07); // keep mode bits
configRegister|= vs_res << 3 | vb_res << 7 | vs << 11  | vb <<13; // set new config
WriteRegister(0x00, configRegister);
vshunt = vs;
}

/*
 * @brief: Sets Sampling Mode
 * @param: Sampling mode
 * @return: none
 */
void INA219::SetMode(SamplingMode md)
{
	configRegister |= md;
	WriteRegister(0x00, configRegister);
}

/*
 * @brief: Resets ADC to default settings
 * @param: none
 * @return: none
 */
void INA219::Reset()
{
	configRegister |= (1<<15); // set reset bit
	WriteRegister(0x00,configRegister);
	configRegister = 0x0000;
}


void INA219::Calibrate(uint16_t cal,double AmpPerLSB)
{
ampPerLSB = AmpPerLSB;
WriteRegister(0x05, cal);
}

/*
 * @brief: Reads current register [0x;01]
 * @param: none
 * @return: shunt current in mA
 */
signed int INA219::ReadCurrent()
{
uint16_t bitmasks[5]= {0x0FFF,0x1FFF,0x2FFF,0x4FFF,0x8FFF};
uint8_t currentReg[2];
signed int current;
ReadRegister(0x01, currentReg);

// Check if current is negative ( Bit 15 is always a sign-bit)
if(currentReg[0] & (1<<15))
{
// Mask out Sign bits
current = (currentReg[0]<<8 | currentReg[1]) & bitmasks[vshunt];
// Reduce by 1
current = current -1;
// Invert and add negative sign
current = ~current;
current = -1 * current;
}
else
{
current = (currentReg[0]<<8 | currentReg[1]);
}
return current;
}

double INA219::ReadCalibratedCurrent()
{
	uint8_t currentReg[2];
	ReadRegister(0x04,currentReg);
	return (currentReg[0]<<8 | currentReg[1])*ampPerLSB;
}

/*
 * @brief: Reads bus voltage register [0x02]
 * @param: none
 * @return: bus voltage, 0xFFFF if overflow is detected
 */
uint16_t INA219::ReadBusVoltage()
{
	uint8_t voltageReg[2];
	uint16_t voltage;
	bool not_ready =true;

	while(not_ready)
	{
	ReadRegister(0x02, voltageReg);
	not_ready = voltageReg[1] & (1<<0);
	}

	// Voltage overflow ?
	if(voltageReg[1] & (1<<1))
	{
		voltage = 0xFFFF;
	}
	else
	{
		voltage = (voltageReg[0] << 8 | voltageReg[1]) >> 3;
	}
	voltage = (voltageReg[0] << 8 | voltageReg[1]) >> 3;
	return voltage;
}

float INA219::ReadPower()
{
	uint8_t powerReg[2];
	ReadRegister(0x03,powerReg);
	return (powerReg[0]<<8 | powerReg[1])*ampPerLSB*20;
}

 } /* namespace ShuntAmplifier */

} /* namespace ADC */
